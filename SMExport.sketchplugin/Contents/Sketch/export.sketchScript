@import "util.js";
@import "Config.js";
@import "AnalyticsLogger.js";
@import "View.js";
@import "CS.js";

@import "layers/TextSwap.js";

// TO DO: Account for layer styling outside rect: borders, shadows, etc
// TO DO: Attach CS to layer upon completing transformation
// TO DO: Smart merge CS to concate properties such as metaData custom fonts

var ExportScrollMotion = ( function() {

    // Requires access to config
    function imageAssetHandler( view, callback ) {
        var layerName = util.unique( util.slugify( view.getSanitizedName() ) ),
            ext = this.config.getImageExtension(),
            filename = this.config.getExportFolderPath() + "/" + layerName + ext,
            src = layerName + ext;

        if( callback ) {
            callback( src, filename );
        }
    }
    function fontAssetHandler( view, callback ) {
        var nsfont = [[[( view.layer ) style] textStyle] attributes].NSFont,
            fontName = String( [nsfont fontName] );

        if( callback ) {
            callback( nsfont, fontName );
        }
    }
    function rectForOverlay( view, parentView ) {
        var pos = parentView ? view.getLayoutRelativeTo( parentView ) : view.getAbsoluteLayout();

        return {
            width: util.toPx( pos.width ),
            height: util.toPx( pos.height ),
            x: util.toPx( pos.x ),
            y: util.toPx( pos.y )
        };
    }

    function bordersRequireRastering( view ) {
        var borders = [[[( view.layer ) style] borders] array],
            enabled = 0,
            types = [],
            requiresRastering = false;

        util.forEach( borders, function( border ) {
            if( [border isEnabled] ) {
                enabled += 1;
                types.push( [border fillType] );
            }
        } );

        if( !( requiresRastering = requiresRastering || enabled > 1 ) ) {
            // A color fill (0) or a gradient (1)
            requiresRastering = types.filter( function( type ) {
                return type > 0;
            } ).length > 0;
        }

        return requiresRastering;
    }
    function fillsRequireRastering( view ) {
        var fills = [[[( view.layer ) style] fills] array],
            enabled = 0,
            types = [],
            requiresRastering = false;

        util.forEach( fills, function( fill ) {
            if( [fill isEnabled] ) {
                enabled += 1;
                types.push( [fill fillType] );
            }
        } );

        if( !( requiresRastering = requiresRastering || enabled > 1 ) ) {
            // A color fill (0), gradient (1) or pattern (4)
            requiresRastering = types.filter( function( type ) {
                return type > 0;
            } ).length > 0;
        }

        return requiresRastering;
    }
    function shadowsRequireRastering( view ) {
        var shadows = [[[( view.layer ) style] shadows] array],
            enabled = 0,
            requiresRastering = false;

        util.forEach( shadows, function( shadow ) {
            if( [shadow isEnabled] ) {
                enabled += 1;
            }
        } );

        return requiresRastering || enabled > 0;
    }
    function innerShadowsRequireRastering( view ) {
        var shadows = [[[( view.layer ) style] innerShadows] array],
            enabled = 0,
            requiresRastering = false;

        util.forEach( shadows, function( shadow ) {
            if( [shadow isEnabled] ) {
                enabled += 1;
            }
        } );

        return requiresRastering || enabled > 0;
    }
    function viewRequiresRastering( view ) {
        var kind = view.getLayerKind(),
            requiresRastering = false;

        if( kind === "Bitmap" ) {
            return true;
        } else if( kind === "Artboard" || kind === "Slice" ) {
            return false;
        } else if( kind === "LayerGroup" ) {
            util.forEach( view.subviews(), function( subview ) {
                if( !requiresRastering ) {
                    requiresRastering = viewRequiresRastering( subview );
                }
            } );
        } else {
            if( !requiresRastering ) {
                requiresRastering = bordersRequireRastering( view );
            }
            if( !requiresRastering ) {
                requiresRastering = fillsRequireRastering( view );
            }
            if( !requiresRastering ) {
                requiresRastering = shadowsRequireRastering( view );
            }
            if( !requiresRastering ) {
                requiresRastering = innerShadowsRequireRastering( view );
            }
        }

        return requiresRastering;
    }

    function explicitMatchViewsToButtonStates( view ) {
        var priority = [ "normal", "down", "on", "downOn" ],
            stateNames = {
                normal: "normal,default,regular".split( "," ),
                down: "down,tap,highlight".split( "," ),
                on: " on,toggled,toggledon,toggled on".split( "," ),
                downOn: "downon,down on,ondown,on down,toggleddown,toggled down".split( "," )
            },
            matchedStates = { normal: [], down: [], on: [], downOn: [] },
            unmatched = [],
            subviews;

        if( view.hasSubviews ) {
            subviews = view.subviews();

            if( subviews.length > 1 ) {
                util.forEach( view.subviews(), function( subview ) {
                    var layerName = subview.name.toLowerCase(),
                        matched = false;

                    unmatched.push( subview );
                    priority.forEach( function( state ) {
                        var matchPattern = new RegExp( stateNames[ state ].join( "|" ), "i" ),
                            matches = layerName.match( matchPattern );

                        if( matches ) {
                            matchedStates[ state ].push( subview );
                        }
                    } );
                } );
            } else {
                matchedStates.normal.push( subviews[ 0 ] );
            }
        } else {
            matchedStates.normal.push( view );
        }

        // Conflict resolution: filter duplicates beginning with less specific state names.
        // Coincidently this is priority listing
        matchedStates.unmatched = unmatched;
        priority.unshift( "unmatched" );

        priority.forEach( function( state, i ) {
            matchedStates[ state ] = matchedStates[ state ].filter( function( item ) {
                for( var ii = i + 1, iilen = priority.length; ii < iilen; ii++ ) {
                    if( priority[ ii ] === state ) { continue; }

                    for( var jj = 0, jjlen = matchedStates[ priority[ ii ] ].length; jj < jjlen; jj++ ) {
                        if( matchedStates[ priority[ ii ] ][ jj ].name === item.name ) {
                            return false;
                        }
                    }
                }

                return true;
            } );
        } );

        return matchedStates;
    }
    function implicitMatchViewsToButtonStates( view ) {
        var matchedStates = explicitMatchViewsToButtonStates( view ),
            unmatched = matchedStates.unmatched;

        // If empty down state, move on state views into down state
        if( matchedStates.down.length === 0 && matchedStates.on.length > 0 ) {
            matchedStates.down.push( matchedStates.on.shift() );
        }

        // If empty downOn state and filled on state, clone on state views into downOn state
        if( matchedStates.downOn.length === 0 && matchedStates.on.length > 0 ) {
            matchedStates.downOn.push( matchedStates.on[ matchedStates.on.length - 1 ] );
        }

        // Dump unmatched views into normal view array
        matchedStates.normal = matchedStates.normal.concat( unmatched );

        return matchedStates;
    }

    /**
        * @desc Check if layers and sublayers require rasterizing for button export
        * param {object|object[]} views - array of View instances
        * returns {boolean}
    */
    function buttonStateViewsRequiresRastering( views ) {
        var requiresRastering = false,
            textViews = [],
            otherViews = [];

        views = ( views instanceof Array ) ? views : [ views ];

        function identifyViewAndChildren( view ) {
            var kind = view.getLayerKind(),
                ret = { textViews: [], otherViews: [] },
                childVal;

            if( view.hasSubviews ) {
                util.forEach( view.subviews(), function( subview ) {
                    childVal = identifyViewAndChildren( subview );
                    ret.textViews = ret.textViews.concat( childVal.textViews );
                    ret.otherViews = ret.otherViews.concat( childVal.otherViews );
                } );
            }

            if( kind === "Text" ) {
                ret.textViews.push( view );
            } else if( kind !== "LayerGroup" ) {
                ret.otherViews.push( view );
            }

            return ret;
        }

        util.forEach( views, function( view ) {
            var kind = view.getLayerKind(),
                child;

            requiresRastering = viewRequiresRastering( view );
            child = identifyViewAndChildren( view );
            textViews = textViews.concat( child.textViews );
            otherViews = otherViews.concat( child.otherViews );

        } );

        return requiresRastering || textViews.length > 1 || otherViews.length > 1;
    }

    function getTextAlignment( layer ) {
        var alignment = [layer textAlignment],
            values = [ "left", "right", "center", "justify", "natural" ];

        // Return "natural" alignment as left
        return ( alignment == values.indexOf( "natural" ) ) ? values[ 0 ] : values[ alignment ];
    }

    function getRgba( color ) {
        var rgba,
            retRgba = { r:0.0, g:0.0, b:0.0 ,a: 1.0 };
        if( color.className && String( color.className() ) === "MSColor" ) {
            // (r:0.816204 g:0.007513 b:0.106696 a:1.000000)
            rgba = color.RGBADictionary();
            util.forEach( rgba, function( val, key ) {
                retRgba[ key ] = key !== "a" ? Math.round( Number( val ) * 255 ) : Number( val );
            } );
        } else if( ( /^rgba?\((?:\d\.\d*,?){3,4}\)$/ ).test( String( color ) ) ) {
            // rgba(0.290196,0.290196,0.290196,1.000000)
            rgba = String( color ).match( new RegExp( "\\(([^\\)]*)\\)" ) )[ 1 ].split( "," );

            [ "r", "g", "b", "a" ].forEach( function( key, i ) {
                if( rgba[ i ] ) {
                    retRgba[ key ] = key !== "a" ? Math.round( Number( rgba[ i ] ) * 255 ) : Number( rgba[ i ] );
                }
            } );
        }

        return retRgba;
    }


    return util.Object.extend( {
        init: function( ctx ) {
            this._super( ctx );

            this.config = Config.create( ctx );
        },
        processLayers: function( layers, csOrientation, csFontSize ) {
            var context = this.context,
                doc = this.context.document,
                plugin = this.context.plugin,

                layersForTransformation = layers,
                eligibleViews = [],
                eligibleArtboardViews = [],
                transformedLayers = [],
                viewBind = View.create( context ),
                viewBindingControl = new ViewBindingController(),
                cs = ContentSpec.create( context ),

                boundImageAssetHandler = imageAssetHandler.bind( this );

                csOrientation = csOrientation || "landscape";
                csFontSize = csFontSize || 14,

                shouldMergeLayerCS = !this.config.getSettingsKeyValue( "cleanExport" );

            var textSwap = TextSwap.create( context );
            textSwap.setSMOrientationForCS( csOrientation );

            viewBindingControl.layerKindRegistry( "default", function( bindObj ) {
                var view = bindObj.getView(),
                    shouldBeExtracted = view.shouldExtractClippingMask();

                // Extract as image
                if( shouldBeExtracted ) {
                    viewBindingControl.layerKindGenerators[ "Bitmap" ].object( bindObj );
                }
            } );
            viewBindingControl.layerKindRegistry( "Artboard", function( bindObj ) {
                var view = bindObj.getView(),
                    page = cs.make( "page" ),
                    layerCS = view.getLayerCS(),
                    id = String( [( view.layer ) objectID] );

                page.setKeyValue( "displayName", view.getSanitizedName() );

                // Merge preexisting content spec properties
                if( layerCS && shouldMergeLayerCS ) {
                    // Set preexisting page id
                    id = layerCS.pageId ? layerCS.pageId : id ;

                    page.setValue( util.merge( layerCS, page.value() ) );
                }

                page.setPageId( id );

                // Attach to bindObj
                bindObj.page = page;
            } );

            // TO DO: Rotation
            viewBindingControl.layerKindRegistry( "Bitmap", function( bindObj ) {
                var view = bindObj.getView(),
                    parent = bindObj.getParent(),
                    rect,

                    overlay = cs.make( "image" ),
                    layerCS = view.getLayerCS(),
                    id = String( [( view.layer ) objectID] );

                boundImageAssetHandler( view, function( src, filename ) {
                    overlay.setKeyValue( "images", [ src ] );

                    bindObj.exportFiles.push( util.Command.create(
                        // Create artboard specifically for exporting layer
                        function() {
                            var dupView = view.duplicate(),
                                dupFrame = [( dupView.layer ) frame],
                                artboard = [MSArtboardGroup new],
                                artFrame = [artboard frame];

                            view = viewBind.make( artboard );

                            [( dupView.layer ) moveToLayer:artboard beforeLayer:null];
                            [dupFrame setX:0];
                            [dupFrame setY:0];

                            [artFrame setWidth:[dupFrame width]];
                            [artFrame setHeight:[dupFrame height]];
                            [artFrame setX:-999999];
                            [artFrame setY:-999999];

                            [( doc.currentPage() ) addLayers:[ artboard ]];
                        },

                        // Delete artboard
                        function() {
                            view.removeFromParent();
                        }, {
                            getView: function() { return view },
                            target: filename
                    } ) );
                } );

                rect = parent ? rectForOverlay( view, parent.getView() ) : rectForOverlay( view );
                overlay.setLayouts( csOrientation, util.merge( rect, {
                    "horizontalAlign": "left",
                    "verticalAlign": "top"
                } ) );
                overlay.setKeyValue( "displayName", view.getSanitizedName() );
                overlay.setOverlayId( view.layer.objectID() );

                overlay.setKeyValue( "hidden", view.isHidden() );
                overlay.setKeyValue( "alpha", Number( [[[( view.layer ) style] contextSettings] opacity] ) );

                // Merge preexisting content spec properties
                if( layerCS && shouldMergeLayerCS ) {
                    // Clear layer content spec if overlay is a different type
                    if( cs.typeofOverlay( layerCS ) !== cs.typeofOverlay( overlay.value() ) ) {
                        layerCS = view.clearLayerCS().getLayerCS();
                    } else {
                        // Set preexisting overlay id
                        id = layerCS.overlayId ? layerCS.overlayId : id;
                    }

                    overlay.setValue( util.merge( layerCS, overlay.value() ) );
                }

                overlay.setOverlayId( id );

                // Attach to bindObj
                bindObj.overlay = overlay;
            } );
            viewBindingControl.layerKindRegistry( "LayerGroup", function( bindObj ) {
                var view = bindObj.getView();

                // Reset value
                this.stopAutoApplyBindingForChildren = false;

                // If layerGroup has clipping mask and no bindings,
                // export layerGroup as a flattened Bitmap
                if( view.hasClippingMask && util.values( view.getNameAttributes() ).length === 0 ) {
                    viewBindingControl.layerKindGenerators[ "Bitmap" ].object( bindObj );
                    this.stopAutoApplyBindingForChildren = true;
                }

                // Defer to binding
            } );

            // TO DO: Rotation
            viewBindingControl.layerKindRegistry( "Text", function( bindObj ) {
                var parent      = bindObj.getParent(),
                    textExports = textSwap.makeSMOverlay( bindObj.getView(), parent ? parent.getView() : null );

                bindObj.overlay = textExports.overlay;
                bindObj.exportFonts = textExports.exports;
            } );

            // Ignore
            viewBindingControl.bindingRegistry( "-" , {
                stopAutoApplyBindingForChildren: true
            } );

            // Flatten
            viewBindingControl.bindingRegistry( "*" , {
                stopAutoApplyBindingForChildren: true,
                compose: function( bindObj, args ) {
                    viewBindingControl.layerKindGenerators[ "Bitmap" ].object( bindObj );
                }
            } );

            // Button
            // TO DO: Rotation
            // TO DO: Refactor state rasterization removing explicit references to states
            viewBindingControl.bindingRegistry( "B" , {
                stopAutoApplyBindingForChildren: true,
                compose: function( bindObj, args ) {
                    var view = bindObj.getView(),
                        parent = bindObj.getParent(),
                        rect,

                        overlay,
                        layerCS = view.getLayerCS(),

                        // TO DO: Refactor solution to preserve common overlay props if type differs
                        layerCSActions = { "actions": layerCS.actions || [] },
                        id = String( [( view.layer ) objectID] ),

                        requiresRastering = view.getLayerValueForKey( "exportAsImage" ) || false,
                        inspectorToggle = view.getLayerValueForKey( "toggle" ) || false;

                    // Reset export files
                    bindObj.exportFonts = [];
                    bindObj.exportFiles = [];

                    // Basic button properties
                    var basicButtonDownState,
                        normalStates = [], downStates = [],
                        textView, textPos, textColor, downColor,
                        pos, border, cornerRadius,
                        fill, downFill;

                    var stateViews = implicitMatchViewsToButtonStates( view ),
                        states = Object.getOwnPropertyNames( stateViews ),
                        unmatchedStateViews = stateViews.unmatched;

                    // Remove unmatched
                    states.splice( states.indexOf( "unmatched" ), 1 );

                    if( !inspectorToggle ) {
                        // Remove on and downOn
                        states.splice( states.indexOf( "on" ), 1 );
                        states.splice( states.indexOf( "downOn" ), 1 );
                    } else {
                        if( stateViews.on.length > 0 ) {
                            requiresRastering = requiresRastering || buttonStateViewsRequiresRastering( stateViews.on );
                        }
                        if( stateViews.downOn.length > 0 ) {
                            requiresRastering = requiresRastering || buttonStateViewsRequiresRastering( stateViews.downOn );
                        }
                    }

                    if( stateViews.normal.length > 0 ) {
                        requiresRastering = requiresRastering || buttonStateViewsRequiresRastering( stateViews.normal );
                    }

                    if( stateViews.down.length > 0 ) {
                        requiresRastering = requiresRastering || buttonStateViewsRequiresRastering( stateViews.down );
                    }

                    overlay = cs.make( !requiresRastering ? "button" : "image_button" );
                    overlay.setKeyValue( "displayName", view.getSanitizedName() );
                    overlay.setKeyValue( "toggle", inspectorToggle );

                    // "Image" button
                    if( requiresRastering ) {
                        // Pass state views to overlay image properties
                        states.forEach( function( state ) {
                            var stateView = stateViews[ state ][ 0 ],
                                buttonStateName = state === "normal" ? "images" :
                                                  "images" + state.replace( /^(\w)/, function( m ) { return m.toUpperCase(); } );

                            if( stateView ) {
                                boundImageAssetHandler( stateView, function( src, filename ) {
                                    overlay.setKeyValue( buttonStateName, [ src ] );

                                    bindObj.exportFiles.push( util.Command.create(
                                        // Create artboard specifically for exporting layer
                                        function() {
                                            var artboard = [MSArtboardGroup new],
                                                artFrame = [artboard frame],
                                                group = [[MSLayerGroup alloc] init],
                                                gFrame = [group frame],
                                                dupView,
                                                dupFrame,
                                                exportFrame;

                                            view = viewBind.make( artboard );

                                            // Set group name to first state layer name
                                            group.name = stateViews[ state ][ 0 ].name;

                                            // Move multiple layers into a single group
                                            if( stateViews[ state ].length > 1 ) {
                                                stateViews[ state ].forEach( function( sview ) {
                                                    dupView = sview.duplicate();

                                                    [( dupView.layer ) moveToLayer:group beforeLayer:null];
                                                } );
                                                [group resizeToFitChildrenWithOption:true];
                                                [group moveToLayer:artboard beforeLayer:null];
                                                [gFrame setX:0];
                                                [gFrame setY:0];

                                                exportFrame = gFrame;
                                            } else {
                                                dupView = stateViews[ state ][ 0 ].duplicate();
                                                dupFrame = [( dupView.layer) frame];

                                                [( dupView.layer ) moveToLayer:artboard beforeLayer:null];
                                                [dupFrame setX:0];
                                                [dupFrame setY:0];

                                                exportFrame = dupFrame;
                                            }

                                            [artFrame setWidth:[exportFrame width]];
                                            [artFrame setHeight:[exportFrame height]];
                                            [artFrame setX:-999999];
                                            [artFrame setY:-999999];

                                            [( doc.currentPage() ) addLayers:[ artboard ]];
                                        },

                                        // Delete artboard
                                        function() {
                                            view.removeFromParent();
                                        }, {
                                            getView: function() { return view; },
                                            target: filename
                                    } ) );
                                } );
                            }
                        } );
                    }

                    // "Basic" button
                    else {
                        basicButtonDownState = ( inspectorToggle && stateViews.on.length > 0 ) ? "on" : "down";

                        // Flatten basic button normal state view layerGroups into array
                        stateViews.normal.forEach( function flattenNormalStateViews( stateView ) {
                            if( stateView.hasSubviews ) {
                                util.forEach( stateView.subviews(), flattenNormalStateViews );
                            } else {
                                normalStates.push( stateView );
                            }
                        } );

                        // Flatten basic button down state view layerGroups into array
                        stateViews[ basicButtonDownState ].forEach( function flattenDownStateViews( stateView ) {
                            if( stateView.hasSubviews ) {
                                util.forEach( stateView.subviews(), flattenDownStateViews );
                            } else {
                                downStates.push( stateView );
                            }
                        } );

                        // Capture basic button properties from layers
                        normalStates.some( function( stateView ) {
                            var kind = stateView.getLayerKind(),
                                tempBorder;

                            // Exit loop if properties have been found
                            if( textView && border && fill && pos && cornerRadius ) { return true; }

                            if( kind === "Text" && !textView ) {
                                overlay.setKeyValue( "text", String( [( stateView.layer ) stringValue] ) );

                                textView = stateView;
                                textColor = [( textView.layer ) textColor];
                                textPos = textView.getLayoutRelativeTo( view );
                            } else if( kind === "Rectangle" ) {
                                if( !border ) {
                                    tempBorder = [[[[( stateView.layer ) style] borders] array] firstObject];
                                    // Check if border is enabled
                                    border = [tempBorder isEnabled] ? tempBorder : undefined;
                                }
                                fill = fill || [[[[( stateView.layer ) style] fills] array] firstObject];
                                pos = pos || stateView.getLayoutRelativeTo( view );

                                // We know there are children layers since the layer kind is "Rectangle"
                                cornerRadius = cornerRadius || [[[( stateView.layer ) children] firstObject] cornerRadiusFloat];
                            }
                        } );

                        downStates.some( function( stateView ) {
                            var kind = stateView.getLayerKind();

                            // Exit loop if properties have been found
                            if( downColor && downFill ) { return true; }

                            if( kind === "Text" ) {
                                downColor = downColor || [( stateView.layer ) textColor];
                            }
                            if( kind === "Rectangle" ) {
                                downFill = downFill || [[[[( stateView.layer ) style] fills] array] firstObject];
                            }
                        } );

                        // Assign cg button properties to overlay
                        if( textView ) {
                            overlay.setKeyValue( "font" , String( [( textView.layer ) fontPostscriptName] ) );
                            fontAssetHandler( textView, function( font, fontName ) {
                                bindObj.exportFonts.push( util.Command.create(
                                    // Execute
                                    function( fontFound ) {
                                        if( fontFound ) {
                                            // Do nothing
                                        } else {
                                            // Revert custom font overlays to default font/text
                                            overlay.setKeyValue( "font", "ArialMT" );
                                        }
                                    },

                                    // Undo
                                    function() {},

                                    // Value
                                    {
                                        getView: function() { return textView },
                                        fontName: fontName,
                                        font: font
                                } ) );
                            } );

                            overlay.setKeyValue( "textAlign", getTextAlignment( textView.layer ) );
                            overlay.setKeyValue( "fontSize", [( textView.layer ) fontSize] / csFontSize + "em" );
                            overlay.setKeyValue( "fontColor" , "#" + [textColor hexValue] );
                        }

                        // SmartStudio requires text padding to be an whole number
                        // otherwise the button is completely jacked up
                        if( textPos && pos ) { overlay.setKeyValue( "textPadding",  util.toPx( Math.floor( textPos.x - pos.x ) ) ); }
                        if( downColor || textColor ) {
                            overlay.setKeyValue( "fontPressedColor" , "#" + [( downColor || textColor ) hexValue] );
                        }

                        if( border ) {
                            overlay.setKeyValue( "cgBorderWidth", util.toPx( [border thickness] ) );
                            overlay.setKeyValue( "cgBorderColor", "#" + [[border color] hexValue] );
                            overlay.setKeyValue( "borderAlpha", getRgba( [border color] ).a );
                        }
                        if( fill ) {
                            overlay.setKeyValue( "cgButtonColor", "#" + [[fill color] hexValue] );
                            // overlay.setKeyValue( "cgButtonAlpha" , getRgba( [fill color] ).a );
                        }
                        if( downFill ) {
                            overlay.setKeyValue( "cgButtonPressedColor", "#" + [[downFill color] hexValue] );
                            // overlay.setKeyValue( "cgButtonPressedAlpha", getRgba( [downFill color] ).a );
                        } else if( fill ) {
                            overlay.setKeyValue( "cgButtonPressedColor", "#" + [[fill color] hexValue] );
                        }

                        if( typeof cornerRadius !== undefined && pos ) {
                            // Ensure corner radius doesn't exceed half of smallest dimension
                            overlay.setKeyValue( "cgCornerRadius" , util.toPx(
                                ( cornerRadius <= Math.min( pos.width , pos.height ) / 2 ) ?
                                    cornerRadius : Math.min( pos.width , pos.height ) / 2
                            ) );
                        }
                    }

                    rect = parent ? rectForOverlay( view, parent.getView() ) : rectForOverlay( view );
                    overlay.setLayouts( csOrientation, util.merge( rect, {
                        "horizontalAlign": "left",
                        "verticalAlign": "top"
                    } ) );

                    overlay.setKeyValue( "hidden", view.isHidden() );
                    overlay.setKeyValue( "alpha", Number( [[[( view.layer ) style] contextSettings] opacity] ) );

                    // Merge preexisting content spec properties
                    if( layerCS && shouldMergeLayerCS ) {
                        // Clear layer content spec if overlay is a different type
                        if( cs.typeofOverlay( layerCS ) !== cs.typeofOverlay( overlay.value() ) ) {
                            // layerCS = util.commonProperties( overlay.value(), layerCS );
                            layerCS = view.clearLayerCS().getLayerCS();
                        } else {
                            // Set preexisting overlay id
                            id = layerCS.overlayId ? layerCS.overlayId : id ;
                        }

                        overlay.setValue( util.merge( layerCS, layerCSActions, overlay.value() ) );
                    }

                    overlay.setOverlayId( id );

                    // Attach to bindObj
                    bindObj.overlay = overlay;
                }
            } );

            // Container
            // TO DO: Rotation
            viewBindingControl.bindingRegistry( "C" , {
                compose: function( bindObj, args ) {
                    var view = bindObj.getView(),
                        parent = bindObj.getParent(),
                        rect,

                        overlay = cs.make( "container" ),
                        layerCS = view.getLayerCS(),
                        id = String( [( view.layer ) objectID] ),
                        frame = view.getClippingMask(),
                        scrollFrame = view.getInfluenceLayoutSansStyles(),

                        // Using stub default values if not defined
                        inspectorPaging = view.getLayerValueForKey( "paging" ),
                        inspectorClipToBounds = view.getLayerValueForKey( "clipToBounds" ),
                        inspectorClickThrough = view.getLayerValueForKey( "clickThrough" ),
                        inspectorDrag = view.getLayerValueForKey( "draggable" ),
                        inspectorBounces = view.getLayerValueForKey( "userScrollingBounces" ),
                        inspectorscrollStyle = view.getLayerValueForKey( "scrollerStyle" ),
                        inspectorScrollDir = view.getLayerValueForKey( "userScrolling" ),

                        scrollDir = inspectorScrollDir ? inspectorScrollDir :
                                    scrollFrame.width > frame && scrollFrame.height > frame.height ? "both" :
                                    scrollFrame.width > frame.width ? "horizontal" :
                                    scrollFrame.height > frame.height ? "vertical" :
                                    "none";

                    overlay.setKeyValue( "userScrolling" , scrollDir );
                    overlay.setKeyValue( "contentHeight" , util.toPx( scrollFrame.height ) );
                    overlay.setKeyValue( "contentWidth" , util.toPx( scrollFrame.width ) );

                    rect = parent ? rectForOverlay( view, parent.getView() ) : rectForOverlay( view );
                    overlay.setLayouts( csOrientation, util.merge( rect, {
                        "horizontalAlign": "left",
                        "verticalAlign": "top"
                    } ) );
                    overlay.setKeyValue( "displayName", view.getSanitizedName() );


                    //
                    // Clean up invalid "tapThrough" property
                    //
                    var invalidTapThrough = view.getLayerValueForKey( "tapThrough" );

                    if( typeof inspectorClickThrough === "undefined" &&
                        typeof invalidTapThrough !== "undefined" ) {
                        inspectorClickThrough = invalidTapThrough;
                    }

                    // Clear layer attribute
                    view.clearLayerKey( "tapThrough" );

                    if( typeof layerCS.tapThrough !== "undefined" ) {
                        delete layerCS.tapThrough;
                    }
                    //
                    // End clean up
                    //

                    if( typeof inspectorPaging !== "undefined" ) {
                        overlay.setKeyValue( "paging" , inspectorPaging );
                    }
                    if( typeof inspectorClipToBounds !== "undefined" ) {
                        overlay.setKeyValue( "clipToBounds" , inspectorClipToBounds );
                    }
                    if( typeof inspectorClickThrough !== "undefined" ) {
                        overlay.setKeyValue( "clickThrough" , inspectorClickThrough );
                    }
                    if( typeof inspectorDrag !== "undefined" ) {
                        overlay.setKeyValue( "draggable" , inspectorDrag );
                    }
                    if( typeof inspectorBounces !== "undefined" ) {
                        overlay.setKeyValue( "userScrollingBounces" , inspectorBounces );
                    }
                    if( typeof inspectorscrollStyle !== "undefined" ) {
                        overlay.setKeyValue( "scrollerStyle" , inspectorscrollStyle );
                    }

                    overlay.setKeyValue( "hidden", view.isHidden() );
                    overlay.setKeyValue( "alpha", Number( [[[( view.layer ) style] contextSettings] opacity] ) );

                    // Merge preexisting content spec properties
                    if( layerCS && shouldMergeLayerCS ) {
                        // Clear layer content spec if overlay is a different type
                        if( cs.typeofOverlay( layerCS ) !== cs.typeofOverlay( overlay.value() ) ) {
                            layerCS = view.clearLayerCS().getLayerCS();
                        } else {
                            // Set preexisting overlay id
                            id = layerCS.overlayId ? layerCS.overlayId : id ;
                        }

                        overlay.setValue( util.merge( layerCS, overlay.value() ) );
                    }

                    overlay.setOverlayId( id );

                    // Attach to bindObj
                    bindObj.overlay = overlay;
                }
            } );

            // Textfield
            // viewBindingControl.bindingRegistry( "T" , function( bindObj, args ) {
            // } );

            // Process layers excluding layers tagged to be ignored
            util.forEach( layersForTransformation, function( layer ) {
                var layerView = viewBind.make( layer );

                if( !layerView.shouldBeIgnored() ) {
                    if( layerView.isArtboard() ) {
                        eligibleArtboardViews.push( layerView )
                    } else {
                        eligibleViews.push( layerView );
                    }
                }
            } );

            // Reverse artboard array
            eligibleArtboardViews = eligibleArtboardViews.reverse();
            // Concatinate artboards to layers
            eligibleViews = eligibleViews.concat( eligibleArtboardViews );

            // Process eligible layers
            util.forEach( eligibleViews, function( layerView ) {
                var boundLayers = viewBindingControl.applyBindings( layerView );

                transformedLayers = transformedLayers.concat( boundLayers );
            } );

            return transformedLayers;
        }
    } );
} )();

function onExport( context ) {
	var DEBUG_PREVENT_EXPORT = false;

    var doc         = context.document,
        selection   = context.selection,
        plugin      = context.plugin,
        fileManager = [NSFileManager defaultManager];

    function catchError( err ) {
        util.debug.error( "Uncaught error: " + err, err );
        doc.showMessage( "Error" );
    }

    // Set to 3 or lower for production
    util.debug.setLevel( 3 ); // log (5) > debug (4) > info (3) > warn (2) > error (1)

    util.debug.debug( "########## Export start ##########" );

	// Set up
    var exportSM 	= ExportScrollMotion.create( context ),
        cs 			= ContentSpec.create( context ),
        config 		= Config.create( context ),
        analytics 	= AnalyticsLogger.create( context ),

        csFileURL   = [NSURL fileURLWithPath:config.getExportFolderPath() + "/ContentSpec.json"],
		// Selection else all layers on current page
        layersForTransformation  = ( [selection count] > 0 ) ? selection : [[doc currentPage] layers];

    function run() {
        return new util.QueueSync( function( resolve, reject ) {
            if( !config.getExportFolderPath() ) {
                reject( "Sketch project not saved" );
            } else {
                resolve( config.getExportFolderPath() );
            }
        } )
    }

    run()

    // Determine if document is saved
    .then( function( res ) {}, function( err ) {
       // Document is not saved
        var alert        = [COSAlertWindow new],
            iconData     = [NSData dataWithContentsOfURL:[( context.plugin ) urlForResourceNamed:@"icon.png"]],
            icon         = [[NSImage alloc] initWithData:iconData],
            messages,
            index;

        messages = [
            {
                title:  "Hey Now",
                body:   "Save your Sketch project and try again!"
            },
            {
                title:  "Wait",
                body:   "Where's your file? Please save and try again."
            },
            {
                title:  "Come on " + String( NSFullUserName() ),
                body:   "You should know you need to save to export."
            },
            {
                title:  "Forgetting something?",
                body:   "Be sure to save before exporting."
            }
        ];
        index = Math.floor( Math.random() * messages.length );

        [alert setMessageText:messages[ index ].title];
        [alert setInformativeText:messages[ index ].body];

        if( icon ) {
            [alert setIcon:icon];
        }

        [alert runModal];

        // Pass error
        return util.QueueSync.reject( err );
    } )

    // Merge with existing CS
    .then( function() {
        var data,
            json;

        // Attempt to initialize with export folder's content spec to retain data
        if( !config.getSettingsKeyValue( "cleanExport" ) ) {
            data = util.getFileData( csFileURL );

            if( data ) {
                json = util.getJSONObjectWithData( data, true );

                if( json ) {
                    // Convert JSON for use with JavaScript
                    cs.initWithJSON( JSON.parse( String( util.stringifyJSON( json ) ) ) );
                }
            }
        }
    } )

    // Set CS screen support and process layers for CS
    // TO DO: What if an artboard doesn't exist?
    .then( function() {
        return new util.QueueSync( function( resolve, reject ) {

            var fontSize = 14,
                screens,
                orientation,
                transformedLayers;

            // TO DO: Optimize by breaking loop when screen is found
            function setCSScreenSupport( layers ) {
                var view        = View.create( context ),
                    screens     = cs.getScreenSupportScreens(),
                    addScreen   = true,
                    screenSize,
                    orientation;

                util.forEach( layers, function( layer ) {
                    var viewLayer = view.make( layer );

                    if( addScreen ) {
                        // Get layer artboard
                        if( !viewLayer.isArtboard() ) {
                            viewLayer = viewLayer.getParentArtboard();
                        }

                        if( viewLayer && viewLayer.isArtboard() && !viewLayer.shouldBeIgnored() ) {
                            screenSize  = viewLayer.getAbsoluteLayout();
                            orientation = ( screenSize.width < screenSize.height ) ? "portrait" : "landscape";

                            // See if screen size matches an existing screen
                            if( screens.length > 0 ) {
                                screens.some( function( screen ) {
                                    if( screen.width        === screenSize.width &&
                                        screen.height       === screenSize.height &&
                                        screen.orientation  === orientation ) {

                                        // Screen exists; don't add
                                        addScreen = false;
                                        return true;
                                    }
                                } );
                            }

                            if( addScreen ) {
                                cs.addScreenSupportScreen( orientation, screenSize.width, screenSize.height );
                                addScreen = false;
                            }
                        }
                    }
                } );
            }
            function mapCSOverlaysToParent( layers ) {
                var startPageId = cs.getStartPage(),
                    csTypes = {
                        overlay: function( obj ) {
                            var overlay         = obj.overlay,
                                existingCS      = cs.getOverlay( overlay.getOverlayId() ),
                                parent          = obj.getParent ? obj.getParent() : null,
                                parentObject    = parent ? parent.overlay ? parent.overlay : parent.page : null,
                                overlayId;

                            // Generate new overlay id if existing overlay doesn't exist or is a different overlay type
                            if( !existingCS || ( existingCS && existingCS.type !== overlay.value().type ) ) {
                                overlay.setOverlayId( cs.generateOverlayId() );
                            }

                            // Overlay id is stored on layer
                            else {
                                // Check overlay id against cs overlay ids
                                overlayId = cs.generateOverlayId( overlay.getOverlayId() );

                                // Replace id if id is already used
                                if( overlayId !== overlay.getOverlayId() ) {
                                   overlay.setValue( cs.replaceIdWithId( overlay.value(), overlay.getOverlayId(), overlayId ) );
                                }
                            }

                            // Add overlay to content spec
                            cs.appendOverlay( overlay.value() );

                            // Attach content spec to layer
                            if( obj.getView().getLayerCS() ) {
                                obj.getView().setLayerCS( overlay.value() );
                            }

                            // Add overlay reference to parent overlay/page
                            if( parentObject && parentObject.addReferenceByOverlayId ) {
                                parentObject.addReferenceByOverlayId( overlay.getOverlayId() );

                                // Attach content spec to layer
                                if( parent.getView().getLayerCS() ) {
                                    parent.getView().setLayerCS( overlay.value() );
                                }
                            }
                        },
                        page: function( obj ) {
                            var page        = obj.page,
                                existingCS  = cs.getPage( page.getPageId() ),
                                pageId;

                            // Generate new page id if existing page doesn't exist
                            if( !existingCS ) {
                                page.setPageId( cs.generatePageId() );
                            }

                            // Page id is stored on layer
                            else {
                                // Check page id against cs page ids
                                pageId = cs.generatePageId( page.getPageId() );

                                // Replace id if id is already used
                                if( pageId !== page.getPageId() ) {
                                   page.setValue( cs.replaceIdWithId( page.value(), page.getPageId(), pageId ) );
                                }
                            }

                            // Add page to content spec
                            cs.appendPage( page.value() );

                            // Attach content spec to layer
                            if( obj.getView().getLayerCS() ) {
                                obj.getView().setLayerCS( page.value() );
                            }

                            // Set start page if none exists
                            if( !startPageId ) {
                                cs.setStartPage( page.getPageId() );
                                startPageId = page.getPageId();
                            }
                        }
                    };

                return layers.map( function( obj ) {
                    obj.type = ( obj.overlay !== null ) ? "overlay" : ( obj.page !== null ) ? "page" : null;

                    if( obj.type !== null ) {
                        csTypes[ obj.type ]( obj );
                    }

                    return obj;
                } );
            }

            setCSScreenSupport( layersForTransformation );

            screens = cs.getScreenSupportScreens();
            orientation = screens.length > 0 ? screens[ 0 ].orientation : "landscape";

            // Create content spec from layer information
            transformedLayers = exportSM.processLayers( layersForTransformation, orientation, fontSize );
            // Map overlay relationships
            mapCSOverlaysToParent( transformedLayers );

            resolve( transformedLayers );
        } );
    } )

    // Process output
    .then( function( layers ) {
        return new util.QueueSync( function( rootResolve, rootReject ) {

            var targetFolderPath    = config.getExportFolderPath(),
                exportFiles = [],
                exportFonts = [],
                userFonts   = {},
                fontManifest,

                json = cs.value(),
                jsonStr,
                jsonPath,

                resourcesStudioPrefPath = config.getResourcesPath() + "/__studio__preferences.json",
                resourcesResetCSS       = config.getResourcesPath() + "/" + cs.getResetCss(),
                targetStudioPrefPath    = targetFolderPath + "/__studio__preferences.json",
                targetResetCSSPath      = targetFolderPath + "/" + cs.getResetCss();

            function showDialog( title, message ) {
                var alert = [COSAlertWindow new],
                    responseCode;

                [alert setMessageText: title];
                [alert setInformativeText: message];

                return {
                    addButtonWithTitle: function( title ) {
                        [alert addButtonWithTitle: title];
                        return this;
                    },
                    run: function( actionHandler ) {
                        responseCode = [alert runModal];
                        if( actionHandler ) {
                            // 1000 = rightmost button
                            // 1001 = second button from right
                            // 1002 = third button from right
                            // 100 + n
                            actionHandler( responseCode );
                        }
                    }
                };
            }

            /**
                * @desc Prompt user to identify font url, ttf or otf
                * @param {NSFont}
                * @returns {NSUrl|null} font file url
            */
            function promptUserForFontURL( font ) {
                var openPanel   = [NSOpenPanel openPanel],
                    title       = "Please locate font " + [font displayName],
                    fileTypes   = [ "ttf", "otf" ];

                [openPanel setCanChooseFiles:true];
                [openPanel setCanChooseDirectories:false];
                [openPanel setAllowsMultipleSelection:false];
                [openPanel setCanCreateDirectories:false];
                [openPanel setMessage:title];

                // This doesn't appear to be an option as of OSX 10.11
                // [openPanel setTitle:title];

                fileTypes = fileTypes.map( function( type ) {
                    return [@"" stringByAppendingString:type];
                } );

                [openPanel setAllowedFileTypes:fileTypes];

                if( [openPanel runModal] == NSOKButton ) {
                    return [[openPanel URLs] firstObject];
                } else {
                    return null;
                }
            }

            /**
                * @desc Checks cs fonts against found font urls
                * @param {array} fonts -
                * @returns {object} fontManifest -
            */
            function checkManifestForFonts( fonts ) {
                var manifest        = config.getSettingsManifest(),
                    fontManifest    = manifest ? manifest.fonts || {} : {},
                    unregisteredFonts,
                    shouldPromptUser = false,
                    newFonts = {};

                unregisteredFonts = fonts.filter( function( font ) {
                    if( !fontManifest[ [font fontName] ] ) {
                        return true;
                    }
                } );

                // Inform user of missing fonts
                if( unregisteredFonts.length > 0 ) {
                    showDialog( "Missing Font File" + ( unregisteredFonts.length > 1 ? "s" : "" ),
                                "Please locate the font file" + ( unregisteredFonts.length > 1 ? "s" : "" ) + " used in this document:\n" +
                                unregisteredFonts.map( function( font ) {
                                    return [font displayName];
                                } ).join( "\n" ) )
                        .addButtonWithTitle( "OK" )
                        .addButtonWithTitle( "Not Now" )
                        .run( function( res ) {
                            shouldPromptUser = ( res == 1001 ) ? false : true;
                        } );
                }

                // Prompt user to locate missing fonts
                if( shouldPromptUser ) {
                    unregisteredFonts.forEach( function( font ) {
                        var url = promptUserForFontURL( font );

                        if( url ) {
                            newFonts[ [font fontName] ] = [url fileSystemRepresentation];
                        }
                    } );
                }

                // Save missing font paths to font manifest
                if( util.values( newFonts ).length > 0 ) {
                    util.merge( fontManifest, newFonts );
                    manifest.fonts = fontManifest;

                    config.setSettingsManifest( manifest );
                }

                return fontManifest;
            }

            function makeSlice( layer, rect, scaleFactor ) {
                // Old
                // var slice = [[MSExportRequest exportRequestsFromExportableLayer:layer inRect:rect useIDForName:false] firstObject];
                // slice.page = [[doc currentPage] copyIncludingObjectIDS];
                // slice.format = config.getImageExtension().replace( "." , "" );
                // slice.scale = scaleFactor;

                var slice = [MSExportRequest requestWithRect:rect scale:scaleFactor];

                [slice setShouldTrim:false];
                [slice setSaveForWeb:true];
                [slice configureForLayer:layer];

                [slice setFormat:( config.getImageExtension().replace( "." , "" ) )];

                return slice;
            }

            // TO DO: Include in image commands
            function disableMaskForExport( view ) {
                var parentView  = view.parentGroup,
                    maskLayer   = null;

                if( view.hasClippingMask ) {
                    maskLayer = view;
                }

                if( maskLayer === null ) {
                    while( parentView !== null && !parentView.hasClippingMask && !parentView.isArtboard() ) {
                        parentView = parentView.parentGroup;
                    }
                    if( parentView !== null && parentView.hasClippingMask ) {
                        maskLayer = parentView;
                    }
                }

                if( maskLayer !== null ) {
                    maskLayer.disableMask();
                }
                return maskLayer;
            }
            // TO DO: Include in image commands
            function disableHiddenForExport( view ) {
                var parentView  = view.parentGroup,
                    hiddenLayer = null;

                if( view.hasHiddenSubviews() ) {
                    hiddenLayer = view;
                }

                if( hiddenLayer === null ) {
                    while( parentView !== null && !parentView.hasHiddenSubviews() && !parentView.isArtboard() ) {
                        parentView = parentView.parentGroup;
                    }
                    if( parentView !== null && parentView.hasHiddenSubviews() ) {
                        hiddenLayer = parentView;
                    }
                }

                if( hiddenLayer !== null ) {
                    hiddenLayer.disableHidden();
                }
                return hiddenLayer;
            }
            function exportImage( view, filename ) {
                var slice,
                    hasClippingMask = ( view.isFolder() && view.hasClippingMask ) ? true : false,
                    scaleFactors    = config.getExportScaleFactors(),

                    // Get absolute rect--width and height without subviews or style--if layer has clipping mask
                    // Else, get rect including styles
                    rect        = hasClippingMask ? [[( view.layer ) absoluteRect] rect] : [( view.layer) absoluteInfluenceRect],
                    // Get parent layer and disable hidden layers
                    maskLayer   = !hasClippingMask ? disableMaskForExport( view ) : null,

                    // Get parent layer and disable hidden layers
                    hiddenLayer     = !hasClippingMask ? disableHiddenForExport( view ) : null,
                    exportFileExt   = filename.slice( filename.lastIndexOf( "." ) ),
                    exportFilename,
                    imageData;

                scaleFactors.forEach( function( scale ) {
                    if( typeof scale !== "number" ) {
                        util.debug.warn( "Can't export at scale: " + scale );
                        return;
                    }

                    var scaleStr = (scale !== 1 ) ? "@" + scale + "x" : "";

                    slice           = makeSlice( view.layer, rect, scale );
                    exportFilename  = filename.slice( 0, filename.lastIndexOf( "." ) ) + scaleStr + exportFileExt;

                    if( slice ) {
                        // Old
                        // imageData = [MSExportManager dataForRequest:slice];
                        // [imageData writeToFile:exportFilename atomically:true];

                        [slice setName:filename];
                        [doc saveArtboardOrSlice:slice toFile:exportFilename];
                        util.debug.debug( "Writing asset: " + slice + ", to disk: " + exportFilename );

                    } else {
                        util.debug.warn( "Can't slice asset: " + exportFilename );
                    }
                } );

                if( maskLayer ) {
                    maskLayer.enableMask();
                }
                if( hiddenLayer ) {
                    hiddenLayer.enableHidden();
                }
            }

            return new util.QueueSync( function( resolve, reject ) {
                if( util.debug.getLevel() > 3 && DEBUG_PREVENT_EXPORT ) {
                    util.debug.debug( "### Deferring output ###" );
                    reject( "Deferring output" );
                } else if( !json ) {
                    reject( "Content Spec not found" );
                } else if( !layers ) {
                    reject( "Layers not found" );
                } else {
                    util.debug.debug( "Saving to path: " + targetFolderPath );
                    resolve();
                }
            } )

            // Prepare export folder
            .then( function() {
                // Remove export folder based on userSettings
                if( config.getSettingsKeyValue( "cleanExport" ) && [fileManager fileExistsAtPath:targetFolderPath] ) {
                    [fileManager removeItemAtPath:targetFolderPath error:nil];
                }

                // Create export folder if none exists
                if( ![fileManager fileExistsAtPath:targetFolderPath] ) {
                    [fileManager createDirectoryAtPath:targetFolderPath withIntermediateDirectories:true attributes:nil error:nil];
                }
            } )

            // Process scrollmotion assets - images and fonts
            .then( function() {
                // Collect export files
                util.forEach( layers, function( obj ) {
                    exportFiles = exportFiles.concat( obj.exportFiles );
                    exportFonts = exportFonts.concat( obj.exportFonts );
                } );


                // Process fonts against known paths
                // Get unique fonts used
                exportFonts.forEach( function( font ) {
                    if( !userFonts[ font.value.fontName ] ) {
                        userFonts[ font.value.fontName ] = font.value.font;
                    }
                } );

                // Get paths to all unique fonts
                fontManifest = checkManifestForFonts( util.values( userFonts ) );

                // Copy font from manifest or revert overlay to common font
                util.forEach( userFonts, function( nsfont, fontName ) {
                    var path        = fontManifest[ fontName ],
                        fontFound   = path ? !![fileManager fileExistsAtPath:path] : false,
                        fontOverlays,
                        fileName,
                        style;

                    // Pre-process overlays
                    fontOverlays = exportFonts.filter( function( fontObj ) {
                            return fontName === fontObj.value.fontName;
                    } );
                    fontOverlays.forEach( function( fontObj ) {
                        fontObj.execute( fontFound );
                    } );

                    // Add fonts to content spec and scrollmotion folder
                    if( fontFound ) {
                        fileName    = path.split( "/" ).slice( -1 )[ 0 ];
                        style       = fontName.split( "-" ).slice( -1 )[ 0 ];
                        style       = ( fontName !== style ) ? style : "Regular";

                        cs.addFontMetaData( {
                            fileName:       fileName,
                            postScriptName: String( [nsfont fontName] ),
                            fullName:       String( [nsfont displayName] ),
                            familyName:     String( [nsfont familyName] ),
                            style:          style
                        } );

                        util.debug.debug( "Copying from path: " + path + ", to path: " + targetFolderPath + "/" + fileName );
                        [fileManager copyItemAtPath:path toPath:( targetFolderPath + "/" + fileName ) error:nil];
                    }

                    // Post-process overlays
                    fontOverlays.forEach( function( fontObj ) {
                        fontObj.undo();
                    } );
                } );
            } )

            // Save ContentSpec.json
            .then( function() {
                // Save json
                if( json ) {
                    jsonStr     = util.stringifyJSON( json );
                    jsonPath    = targetFolderPath + "/ContentSpec.json";

                    debug.debug( "Writing content spec to path: " + jsonPath );
                    [jsonStr writeToFile:jsonPath atomically:true encoding:NSUTF8StringEncoding error:null];
                }

                // Copy resources
                if( [fileManager fileExistsAtPath:resourcesStudioPrefPath] ) {
                    [fileManager copyItemAtPath:resourcesStudioPrefPath toPath:targetStudioPrefPath error:nil];
                }
                if( [fileManager fileExistsAtPath:resourcesResetCSS] ) {
                    [fileManager copyItemAtPath:resourcesResetCSS toPath:targetResetCSSPath error:nil];
                }
            } )

            // Export images
            .then( function() {
                if( exportFiles.length ) {
                    exportFiles.forEach( function( fileObj ) {
                        fileObj.execute();
                        // Assign plugin context to exportImage context for access to currentPage
                        exportImage( fileObj.value.getView(), fileObj.value.target );
                        fileObj.undo();
                    } );
                }
            } )

            .then( function() {
                util.debug.debug( cs.value() );
                rootResolve();
            } )

            .catch( function( err ) {
                rootReject( err );
            } );
        } );
    } )

    // Log analytics
    .then( function() {
        if( util.debug.getLevel() <= 3 && !DEBUG_PREVENT_EXPORT ) {
            analytics.log( "export", {
                contentSpecInfo: {
                    schemaVersion: cs.getSchema(),
                    resetCssVersion: cs.getResetCss()
                }
            } );
        }
        util.debug.debug( "########## Export end ##########" );
        doc.showMessage( "Done" );
    } )

    // Capture errors
    .catch( function( err ) {
        if( err === "Deferring output" ) {
            doc.showMessage( "Done" );
        } else {
            catchError( err );
        }

        if( util.debug.getLevel() <= 3 && !DEBUG_PREVENT_EXPORT ) {
            analytics.log( "export", {
                errorInfo: {
                    message: String( err )
                }
            } );
        }
    } );
}