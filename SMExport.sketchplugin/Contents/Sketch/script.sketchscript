/* global log , CocoaBridge , Config , Util , ContentSpec , View , ViewBinding */
"use strict";

// jshint ignore:start
@import "sandbox.js";
@import "cocoaBridge.js";
@import "config.js";
@import "contentSpec.js";
@import "view.js";
@import "binding.js";
// jshint ignore:end


// TO DO: Button image button should be sized by the largest state layer

// TO DO: Only Artboards of the same width/height ratio should be exported; all others ignored
// TO DO: User can work at 1x or 2x Artboards
// TO DO: How do slice layers work?
// TO DO: How do symbols work? [layer parentOrSelfIsSymbol]
// TO DO: Figure out how saving works: what folder should be defined for sandbox
// TO DO: Message saved path relative to ~ when complete
// TO DO: Multiple pages? Selections?
// TO DO: Reveal export folder upon completion?
// TO DO: User driven settings prompts? ala Origami

// Global variables for accessing Sketch object model
var $doc,
    $selection,
    contentSpec = new ContentSpec();

// log (1) < debug (2) < info (3) < warn (4) < error (5)
Util.debug.setLevel( 5 );

function initVars( context ) {
    $doc = context.document;
    $selection = context.selection;
}

/* Font functions  */
function getFontManifest() {
    var settingsManifest = Config.settingsManifest.getManifest();
    return settingsManifest.fonts || {};
}
function saveFontManifest( manifest ) {
    manifest = manifest || {};
    var settingsManifest = Config.settingsManifest.getManifest(),
        saveManifest = Config.settingsManifest.saveManifest;
    
    settingsManifest.fonts = manifest;

    saveManifest( settingsManifest );
}
function getFontsDelta( manifest , fonts ) {
    return fonts.filter( function( font ) {
        if( !manifest[ font.fontName() ] ) {
            return true;
        }
    } );
}
function checkManifestForFonts( fonts ) {
    var manifest = getFontManifest(),
        unregisteredFonts = getFontsDelta( manifest , fonts ),
        shouldPromptUser = true,
        newFonts = {},
        key;
    
    if( unregisteredFonts.length > 0 ) {
        // Prompt user with missing fonts
        CocoaBridge.showDialogWithOptions( "Fonts Found" , "Please identify the following font files to add to your ScrollMotion:\n" +
            unregisteredFonts.map( function( font ) {
                return font.displayName();
            } ).join("\n") ).addButtonWithTitle( "OK!" )
                            .addButtonWithTitle( "Not Now" )
                            .run( function( res ) {
                                shouldPromptUser = ( res == 1001 ) ? false : true;
                            } );
    }

    // Prompt user with finder window to locate font paths
    if( shouldPromptUser ) {
        unregisteredFonts.forEach( function( font ) {
            var path = promptUserForFontPath( font );
            
            if( path ) {
                newFonts[ font.fontName() ] = path.fileSystemRepresentation();
            }
        } );
    }

    // Save new font paths to manifest
    if( Util.values( newFonts ).length > 0 ) {
        for( key in newFonts ) {
            manifest[ key ] = newFonts[ key ];
        }
        saveFontManifest( manifest );    
    }
    return manifest;
}
function promptUserForFontPath( font ) {
    var path = CocoaBridge.browseForFile( "Please locate font \"" + font.displayName() + "\"" , [ "otf" , "ttf" ] );
    return path;
}
/* End Font functions */

/* Export functions */

function disableMaskForExport( view ) {
    var parentView = view.parentGroup,
        maskLayer = null;

    if( view.hasClippingMask ) {
        maskLayer = view;
    }

    if( maskLayer === null ) {
        while( parentView !== null && !parentView.hasClippingMask && !parentView.isArtboard() ) {
            parentView = parentView.parentGroup;
        }
        if( parentView.hasClippingMask ) {
            maskLayer = parentView;
        }
    }

    if( maskLayer !== null ) {
        maskLayer.disableMask();
    }
    return maskLayer;
}
function disableHiddenForExport( view ) {
    var parentView = view.parentGroup,
        hiddenLayer = null;

    if( view.hasHiddenSubviews() ) {
        hiddenLayer = view;
    }

    if( hiddenLayer === null ) {
        while( parentView !== null && !parentView.hasHiddenSubviews() && !parentView.isArtboard() ) {
            parentView = parentView.parentGroup;
        }
        if( parentView.hasHiddenSubviews() ) {
            hiddenLayer = parentView;
        }
    }

    if( hiddenLayer !== null ) {
        hiddenLayer.disableHidden();
    }
    return hiddenLayer;
}
function makeSlice( layer , rect , scaleFactor ) {
    var slice = CocoaBridge.MSSliceMaker.slicesFromExportableLayer( layer , rect ).firstObject();
    slice.page = $doc.currentPage().copyLightweight();
    slice.format = Config.exportImgExt.replace( "." , "" );
    slice.scale = scaleFactor;

    return slice;
}
function exportAsImage( view, filename , scaleFactors ) {
    var slice,
        hasClippingMask = ( view.isFolder() && view.hasClippingMask ) ? true : false,
        // Get absolute rect - width and height without subviews or style - if layer has clipping mask
        // Else, get rect including styles
        rect = hasClippingMask ? view.layer.absoluteRect().rect() : view.layer.absoluteInfluenceRect(),
        // Get parent layer and disable mask layers
        maskLayer = !hasClippingMask ? disableMaskForExport( view ) : null,
        // Get parent layer and disable hidden layers 
        hiddenLayer = !hasClippingMask ? disableHiddenForExport( view ) : null,
        exportFileName,
        exportFileExt = filename.slice( filename.lastIndexOf( "." ) ),
        imageData;

    scaleFactors = scaleFactors || [ Config.exportScaleFactor ];
    
    scaleFactors.forEach( function( scale ) {
        if( typeof scale !== "number" ) {
            return;
        }
        var scaleStr = ( scale !== 1 ) ? "@" + scale + "x" : "";
        exportFileName = filename.slice( 0 , filename.lastIndexOf( "." ) ) + scaleStr + exportFileExt;
        
        slice = makeSlice( view.layer , rect , scale );

        Util.debug.debug("Writing asset " + slice + " to disk: " + exportFileName );
        imageData = CocoaBridge.MSSliceExporter.dataForRequest( slice );
        
        Util.saveFileFromData( exportFileName , imageData );
    } );

    if( maskLayer ) {
        maskLayer.enableMask();
    }
    if( hiddenLayer ) {
        hiddenLayer.enableHidden();
    }
}
function handlerExportForProp( view , bindObj, prop ) {
    var overlay = ( bindObj.overlay && bindObj.overlay.type ) ? bindObj.overlay : contentSpec.create( "image" ),
        layerName = Util.unique( Util.slugify( view.getSanitizedName() ) ),
        filename = Config.targetFolder + "/" + layerName,
        ext = Config.exportImgExt,
        src = filename.replace( Config.targetFolder + "/" , "" ) + ext;

    overlay.setKeyValue( prop , [ src ] );
    bindObj.exportFiles.push( { view: view , target: filename + ext } );
    return overlay;
}
function handlerExport( view , bindObj ) {
    return handlerExportForProp( view , bindObj , "images" );
}
function handlerFontExport( view , bindObj ) {
    var overlay = ( bindObj.overlay && bindObj.overlay.type ) ? bindObj.overlay : contentSpec.create( "text" ),
        nsfont = view.layer.style().textStyle().attributes().NSFont,
        style;

        if( overlay.type === "button" ) {
            style = { 
                setCommonText: function() {
                    overlay.setKeyValue( "font" , "Arial-BoldMT" );
                },
                removeTempValues: Util.noop
            };
        } else {
            style = overlay.setText();
        }

    bindObj.exportFonts.push( { view: view , fontName: String( nsfont.fontName() ) , font: nsfont , fontStyle: style } );
}
/* End Export functions */

function output( viewData ) {

    var targetFolder = Config.targetFolder,
        json = contentSpec.getJson(),
        exportFiles = [],
        exportFonts = [],
        userFonts = {},
        fontManifest,
        contentSpecStr,
        contentSpecSrc;

    log( Config.targetFolder );

    // 1. Create folders
    if( Util.folderExists( Config.targetFolder ) ) {
        Util.removeFolder( Config.targetFolder );
    }

    Util.createFolders( Config.targetFolder , CocoaBridge.Array.arrayWithObjects( targetFolder ) );

    // 2. Compile ContentSpec.json, collect export files
    Util.forEach( viewData , function( data ) {
        if( data.type === "overlay" ) {
            contentSpec.appendOverlay( data.overlay );
        } else if( data.type === "page" ) {
            contentSpec.appendPage( data.page );
            json.pageSets.pageSet1.pages.push( data.page.getPageId() );
        }

        exportFiles = exportFiles.concat( data.exportFiles );
        exportFonts = exportFonts.concat( data.exportFonts );
    } );

    // 3. Get unique fonts used in project
    exportFonts.forEach( function( font ) {
        if( !userFonts[ font.fontName ] ) {
            userFonts[ font.fontName ] = font.font;
        }
    } );
    fontManifest = checkManifestForFonts( Util.values( userFonts ) );

    // 3.1. Copy font from manifest or revert overlay to use common font
    Util.forEach( userFonts , function( nsfont , fontName ) {
        var path = fontManifest[ fontName ],
            fontFound = ( path ) ? CocoaBridge.fileExistsAtPath( path ) : false,
            fileName,
            style;

        if( !fontFound ) {
            // Revert all custom font overlays to common font/text
            exportFonts.filter( function( fontObj ) {
                return fontName === fontObj.fontName;
            } ).forEach( function( fontObj ) {
                fontObj.fontStyle.setCommonText();
            } );
        } else {
            fileName = path.split( "/" ).slice( -1 )[ 0 ];
            style = fontName.split( "-" ).slice( -1 )[ 0 ];
            style = ( fontName !== style ) ? style : "Regular";

            contentSpec.addFontMetaData( {
                fileName: fileName,
                postScriptName: String( nsfont.fontName() ),
                fullName: String( nsfont.displayName() ),
                familyName: String( nsfont.familyName() ),
                style: style
            } );
            CocoaBridge.copyItemAtPath( path , Config.targetFolder + "/" + fileName );
        }
    } );

    // 3.2. Remove unfortunate temporary property _text from text overlay
    exportFonts.forEach( function( fontObj ) {
        fontObj.fontStyle.removeTempValues();
    } );


    // 4. Save ContentSpec.json
    if( json ) {
        contentSpecStr = JSON.stringify( json );
        contentSpecSrc = Config.targetFolder + "/ContentSpec.json";
        Util.saveFileFromString( targetFolder , contentSpecSrc , contentSpecStr );
    }

    // 5. Export images
    if( exportFiles ) {
        Util.forEach( exportFiles , function( fileObj ) {
            exportAsImage( fileObj.view , fileObj.target , [ Config.exportScaleFactor , 2.0 ] );
        } );
    }

    // 6. Copy resources
    if( CocoaBridge.fileExistsAtPath( Config.resourcesPath + "/__studio__preferences.json" ) ) {
        CocoaBridge.copyItemAtPath( Config.resourcesPath + "/__studio__preferences.json",
            Config.targetFolder + "/__studio__preferences.json" );
    }
    if( CocoaBridge.fileExistsAtPath( Config.resourcesPath + "/" + contentSpec.getResetCss() ) ) {
        CocoaBridge.copyItemAtPath( Config.resourcesPath + "/" + contentSpec.getResetCss(),
            Config.targetFolder + "/" + contentSpec.getResetCss() );
    }
}
function main( context , viewBinding ) {
    try {
        log("#################################");
        log("### Export ScrollMotion start ###");
        log("#################################");

        var layers = context.document.currentPage().layers(),
            eligibleViews = [],
            contentSpecScreenSize,
            csOrientation,
            csWidth,
            csHeight,
            processResults;

        // 1. Process Arboards and layers without [ignore] binding
        layers = Util.forEach( layers , function( res ) {
            var view = View.create( res );
            if( view.isArtboard() ) {
                if( !view.shouldBeIgnored() ) {
                    eligibleViews.push( view );
                    if( !contentSpecScreenSize ) {
                        contentSpecScreenSize = view.getAbsoluteLayout();
                    }
                }
            }
        } );

        csOrientation = ( contentSpecScreenSize.width < contentSpecScreenSize.height ) ? "portrait" : "landscape";
        csWidth = Number( contentSpecScreenSize.width );
        csHeight = Number( contentSpecScreenSize.height );
        contentSpec.addScreen( csOrientation, csWidth, csHeight );

        // 2. Apply Sketch layer and overlay bindings
        Util.forEach( eligibleViews , function( view ) {
            viewBinding.applyBindings( view );
        } );

        processResults = viewBinding.mapOutput();

        Util.debug.debug( JSON.stringify( processResults ) );

        // 3. Prepare outputs
        output( processResults );

        log("#################################");
        log("#### Export ScrollMotion end ####");
        log("#################################");

    } catch( e ) {
        log( "Uncaught " + e );
        CocoaBridge.showDialog( "Export ScrollMotion Failed" , "An error occurred preventing this project from exporting. Check your layers and try again. If the issue persists, please log a report." );
    }
}

var onRun = function( context ) {

    initVars( context );
    Config.init( context );

    var viewBinding = new ViewBinding();

    // Register handlers for Sketch data models

    // Clipping Mask layers will not be exported with "+" exception,
    // All other layers should be exported
    viewBinding.registerObjectGenerator( "default" , function( bindObj ) {
        var view = bindObj.view,
            shouldBeExtracted = view.shouldExportClippingMask(),
            overlay;

        if( shouldBeExtracted ) {
            overlay = handlerExport( view , bindObj );
            overlay.setOverlayId();
            overlay.setKeyValue( "displayName" , view.getSanitizedName() );

            bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
            bindObj.overlay = overlay;
        }
    } );
    viewBinding.registerObjectGenerator( "Artboard" , function( bindObj ) {
        var view = bindObj.view,
            page = contentSpec.create( "page" );
        page.setPageId();
        page.setKeyValue( "displayName" , view.getSanitizedName() );

        bindObj.page = page;
    } );
    viewBinding.registerObjectGenerator( "Bitmap" , function( bindObj ) {
        var view = bindObj.view,
            overlay = handlerExport( view , bindObj );
        overlay.setOverlayId();
        overlay.setKeyValue( "displayName" , view.getSanitizedName() );


        bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
        bindObj.overlay = overlay;
    } );
    viewBinding.registerObjectGenerator( "LayerGroup" , function( bindObj ) {
        var view = bindObj.view,
            overlay,
            frame,
            scrollFrame,
            scrollHoriz,
            scrollVert,
            scrollDirection = "none";

        // If Layer Group has clipping mask and no bindings, export Layer Group as a flattened Bitmap
        // Else, export Layer Group and continue on to sub views
        if( view.hasClippingMask && Util.values( view.getNameAttributes() ).length === 0 ) {
            viewBinding.objectGenerators[ "Bitmap" ].object( bindObj );
        } else {

            overlay = contentSpec.create( "container" );
            frame = view.getClippingMask();
            scrollFrame = view.getInfluenceLayoutSansStyles();
            scrollHoriz = scrollFrame.width > frame.width;
            scrollVert = scrollFrame.height > frame.height;

            overlay.setOverlayId();
            overlay.setKeyValue( "displayName" , view.getSanitizedName() );

            if( scrollHoriz && scrollVert ) {
                scrollDirection = "both";
            } else if( scrollHoriz ) {
                scrollDirection = "horizontal";
            } else if( scrollVert ) {
                scrollDirection = "vertical";
            }

            overlay.setKeyValue( "userScrolling" , scrollDirection );
            overlay.setKeyValue( "contentHeight" , Util.toPx( scrollFrame.height ) );
            overlay.setKeyValue( "contentWidth" , Util.toPx( scrollFrame.width ) );

            bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );

            // Set width and height with clipping mask
            // Null orientation will use the default orientation
            overlay.setLayouts( null , {
                width: Util.toPx( frame.width ),
                height: Util.toPx( frame.height )
            } );

            bindObj.overlay = overlay;
        }
    } );
    viewBinding.registerObjectGenerator( "Text" , {
        object: function( bindObj ) {
            var view = bindObj.view,
                overlay = contentSpec.create( "text" ),
                textAlign = this.alignment( view.layer );
            overlay.setOverlayId();
            overlay.setKeyValue( "displayName" , view.getSanitizedName() );

            // Not officially exposed
            // Util.log( view.layer.style().textStyle().attributes().NSFont.displayName() );
            // Util.log( view.layer.style().textStyle().attributes().NSFont.familyName() );
            // Util.log( String( view.layer.fontPostscriptName() ) );

            var text = overlay.setText( String( view.layer.stringValue() ) );
            text.setTextAlign( textAlign );
            text.setLineHeight( Util.toPx( view.layer.lineSpacing() ) );
            text.setLetterSpacing( Util.toPx( view.layer.characterSpacing() ) );
            text.setColor( Util.toHex( view.layer.textColor() ) );
            text.setFontSize( Util.toPx( view.layer.fontSize() ) );
            text.setCustomFont( String( view.layer.fontPostscriptName() ) , String( view.layer.style().textStyle().attributes().NSFont.familyName() ) );

            bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
            bindObj.overlay = overlay;
            handlerFontExport( view , bindObj );
        },
        alignment: function( layer ) {
            var alignment = layer.textAlignment();

            if( alignment == 1 ) {
                return "right";
            } else if( alignment == 2 ) {
                return "center";
            } else if( alignment == 3 ) {
                return "justify";
            } else {
                return "left"; // ( 0 )
            }
        }
    } );

    // Register handlers for Content Spec data model generation
    viewBinding.registry( "default" , function( bindObj , args ) {
        //we do nothing!
    } );
    viewBinding.registry( "ignore" , {
        stopAutoApplyBindingForChildren: true
    } );
    viewBinding.registry( "flat" , {
        compose: function( bindObj , args ) {
            var overlay = bindObj.overlay;
            overlay.convertToOverlay( "image" , "overlayId" , "layouts" , "displayName" );
            bindObj.overlay = overlay;

            viewBinding.objectGenerators[ "Bitmap" ].object( bindObj );
        },
        stopAutoApplyBindingForChildren: true
    } );
    viewBinding.registry( "btn" , {
        init: function() {
            // This method will only be called when this binding first be used.
        },
        compose: function( bindObj , args ) {
            var view = bindObj.view,
                overlay = bindObj.overlay,
                views,
                needExport,

                // Helpers for overlay properties
                states = [],
                pos,
                textView = null,
                textAlign,
                textPos,
                textColor,
                border,
                cornerRadiusFloat,
                fill,
                pressedFill;


            // Exit if view is not a LayerGroup; view will be exported as an image
            if( !view.hasSubviews ) {
                return;
            }

            views = view.subviews();
            needExport = bindObj.requiresExport( view );


            // Doesn't currently support sub layer groups
            function buttonRequiresExport( view ) {
                var textLayers = [],
                    stateLayers = [];

                if( needExport ) { return true; }

                Util.forEach( view.subviews() , function( subview ) {
                    var kind = subview.getLayerKind();
                    if( kind === "LayerGroup" ) {
                        needExport = true;
                    } else if( kind === "Text" ) {
                        textLayers.push( subview );
                    } else {
                        stateLayers.push( subview );
                    }
                } );

                Util.debug.info( "button: " + view.name + ", has ",
                    textLayers.length + " text layers and ",
                    stateLayers.length + " state layers." );

                // Export if <> 1 text element
                if( textLayers.length === 1 ) {
                    if( textLayers[ 0 ] ) {
                        needExport = bindObj.requiresExport( textLayers[ 0 ] );
                    }
                } else { 
                    Util.debug.debug( view.name + " contains " + textLayers.length + " text layers" );
                    return true;
                }

                // Export if more than 4 states: images, imagesDown, imagesOn, and imagesDownOn
                if( !needExport && stateLayers.length <= 4 ) {
                    Util.forEach( stateLayers , function( view ) {
                        if( bindObj.requiresExport( view ) ) {
                            needExport = true;
                        }
                    } );
                } else {
                    if( !needExport ) {
                        Util.debug.debug( needExport , view.name + " contains too many state layers" );
                    }
                    needExport = true;
                }

                return needExport;
            }

            // Determine if overlay must be exported as images
            needExport = buttonRequiresExport( view );

            // If requires images, flatten button states
            // Else, capture button properties
            if( needExport ) {
                overlay.convertToOverlay( "button" , "layouts" , "displayName" );

                Util.forEach( views , function( subview ) {
                    var bindings = subview.getNameAttributes(),
                        kind = subview.getLayerKind();

                    if( kind === "Text" ) {
                        // Not yet implemented
                    } else if( kind === "Rectangle" || kind === "LayerGroup" ) {
                        if( bindings.state ) {
                            if( bindings.state.indexOf( "down" ) > -1 ) {
                                overlay = handlerExportForProp( subview , bindObj , "imagesDown" );
                                states.push( "down" );
                            } else if( bindings.state.indexOf( "on" ) > -1 ) {
                                overlay = handlerExportForProp( subview , bindObj , "imagesOn" );
                                states.push( "on" );
                            } else if( bindings.state.indexOf( "downOn" ) > -1 ) {
                                overlay = handlerExportForProp( subview , bindObj , "imagesDownOn" );
                                states.push( "downOn" );
                            }
                        } else {
                            // Normal state
                            overlay = handlerExport( subview , bindObj );
                        }
                    }
                } );

                // Enable toggle if conditions exist
                if( view.getNameAttributes().btn.indexOf( "toggle" ) > -1 ||
                    ( states.indexOf( "down" ) > -1 && states.indexOf( "on" ) > -1 && states.indexOf( "downOn" ) > -1 ) ) {
                        overlay.setKeyValue( "toggle" , true );
                }
            } else {
                overlay.convertToOverlay( "cgbutton" , "layouts" , "displayName" );

                Util.forEach( views , function( subview ) {
                    var bindings = subview.getNameAttributes(),
                        kind = subview.getLayerKind();

                    if( kind === "Text" ) {
                        overlay.setKeyValue( "text" , String( subview.layer.stringValue() ) );
                        textPos = subview.getLayoutRelativeTo( view );
                        textAlign = viewBinding.objectGenerators[ "Text" ].alignment( subview.layer );
                        textColor = subview.layer.textColor();
                        textView = subview;

                    } else if( kind === "Rectangle" ) {

                        if( bindings.state ) { 
                            if( bindings.state.indexOf( "down" ) > -1 ) {
                                // Tapped state
                                if( !pressedFill ) { pressedFill = subview.layer.style().fills().array()[ 0 ]; }
                                states.push( "down" );
                            } else if( bindings.state.indexOf( "on" ) > -1 ) {
                                // Toggled state
                                if( !pressedFill ) { pressedFill = subview.layer.style().fills().array()[ 0 ]; }
                                states.push( "on" );
                            } else if( bindings.state.indexOf( "downOn" ) > -1 ) {
                                // Not a valid CG button state; capture anyways
                                states.push( "downOn" );
                            }
                        } else {
                            // Normal state
                            if( !border ) {
                                border = subview.layer.style().borders().array()[ 0 ];

                                // We know there are children layers since the layer kind is "Rectangle"
                                cornerRadiusFloat = subview.layer.children()[0].cornerRadiusFloat();
                            }
                            if( !fill ) { fill = subview.layer.style().fills().array()[ 0 ]; }
                            if( !pos ) {
                                pos = subview.getLayoutRelativeTo( view );
                            }
                        }
                    }
                } );

                if( states.indexOf( "on" ) > -1 ) {
                    overlay.setKeyValue( "toggle" , true );
                }

                overlay.setKeyValue( "font" , String( textView.layer.fontPostscriptName() ) );
                overlay.setKeyValue( "textAlign" , textAlign );
                overlay.setKeyValue( "textPadding" , Util.toPx( textPos.x - pos.x ) );
                overlay.setKeyValue( "cgBorderWidth" , Util.toPx( border.thickness() ) );
                overlay.setKeyValue( "cgBorderColor" , Util.toHex( border.color() ) );
                overlay.setKeyValue( "borderAlpha" , Number( Util.toRgba( border.color() ).split( "," ).pop() ) );
                
                overlay.setKeyValue( "cgButtonColor" , Util.toHex( fill.color() ) );
                // overlay.setKeyValue( "cgButtonAlpha" , Number( Util.toRgba( fill.color() ).split( "," ).pop() ) );
                
                if( pressedFill !== undefined ) {
                    overlay.setKeyValue( "cgButtonPressedAlpha" , Number( Util.toRgba( pressedFill.color() ).split( "," ).pop() ) );
                    overlay.setKeyValue( "cgButtonPressedColor" , Util.toHex( pressedFill.color() ) );
                }
                
                overlay.setKeyValue( "fontColor" , Util.toHex( textColor ) );
                overlay.setKeyValue( "fontPressedColor" , Util.toHex( textColor ) );
                
                // Ensure corner radius doesn't exceed half of smallest dimension
                overlay.setKeyValue( "cgCornerRadius" , Util.toPx( 
                    ( cornerRadiusFloat <= Math.min( pos.width , pos.height ) / 2 ) ? 
                        cornerRadiusFloat : Math.min( pos.width , pos.height ) / 2
                ) );
            }

            bindObj.overlay = overlay;
            if( textView !== null ) { handlerFontExport( textView , bindObj ); }
        },
        actions: function( bindObj , args ) {},
        //we will take the children from here
        stopAutoApplyBindingForChildren: true
    } );
    // Binding.registry( "container" , function( layer , args , outputRef ) {
    //     // scroll
    //     // paging
    // } );
    // Binding.registry( "text" , function( layer , args , outputRef ) {} );
    // Binding.registry( "textfield" , function( layer , args , outputRef ) {} );
    // Binding.registry( "proxy" , function( layer , args , outputRef ) {} );

    main( context , viewBinding );
    $doc.showMessage( "Project exported to \"" + Config.targetFolder + "\"" );
};