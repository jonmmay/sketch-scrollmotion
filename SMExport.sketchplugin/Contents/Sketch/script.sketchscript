/* global log , CocoaBridge , Config , Util , ContentSpec , View , ViewBinding */
"use strict";

@import "sandbox.js";
@import "cocoaBridge.js";
@import "config.js";
@import "contentSpec.js";
@import "view.js";
@import "binding.js";

// Blocker TO DO: Files must comply with WorkCloud naming scheme

// TO DO: An image button should be sized by the largest state layer

// TO DO: Only Artboards of the same width/height ratio should be exported; all others ignored
// TO DO: User can work at 1x or 2x Artboards
// TO DO: How do slice layers work?
// TO DO: How do symbols work? [layer parentOrSelfIsSymbol]
// TO DO: Figure out how saving works: what folder should be defined for sandbox
// TO DO: Message saved path relative to ~ when complete
// TO DO: Multiple pages? Selections?
// TO DO: Reveal export folder upon completion?
// TO DO: User driven settings prompts? ala Origami

// Global variables for accessing Sketch object model
var $doc,
    $selection,
    contentSpec = new ContentSpec();

function initVars( context ) {
    $doc = context.document;
    $selection = context.selection;
}

/* Font functions  */
function getFontManifest() {
    var resourcesPath = Config.resourcesPath,
        manifestPath = resourcesPath + "/.fontmanifest";

    if( !CocoaBridge.fileExistsAtPath( manifestPath ) ) {
        saveFontManifest();
    }
    return CocoaBridge.jsonWithContentsOfFile( manifestPath );
}
function saveFontManifest( manifest ) {
    manifest = manifest || {};
    var resourcesPath = Config.resourcesPath,
        manifestPath = resourcesPath + "/.fontmanifest";

    Util.saveFileFromString( resourcesPath , manifestPath , CocoaBridge.stringify( manifest , true ) );
}
function getFontsDelta( manifest , fonts ) {
    return fonts.filter( function( font ) {
        if( !manifest[ font.fontName() ] ) {
            return true;
        }
    } );
}
function checkManifestForFonts( fonts ) {
    var manifest = getFontManifest(),
        unregisteredFonts = getFontsDelta( manifest , fonts ),
        shouldPromptUser = true,
        newFonts = {},
        key;
    
    if( unregisteredFonts.length > 0 ) {
        // Prompt user with missing fonts
        CocoaBridge.showDialogWithOptions( "Fonts Found" , "Please identify the following font files to add to your ScrollMotion:\n" +
            unregisteredFonts.map( function( font ) {
                return font.displayName();
            } ).join("\n") ).addButtonWithTitle( "OK!" )
                            .addButtonWithTitle( "Not Now" )
                            .run( function( res ) {
                                shouldPromptUser = ( res == 1001 ) ? false : true;
                            } );
    }

    // Prompt user with finder window to locate font paths
    if( shouldPromptUser ) {
        unregisteredFonts.forEach( function( font ) {
            var path = promptUserForFontPath( font );
            
            if( path ) {
                newFonts[ font.fontName() ] = path.fileSystemRepresentation();
            }
        } );
    }

    // Save new font paths to manifest
    if( Util.values( newFonts ).length > 0 ) {
        for( key in newFonts ) {
            manifest[ key ] = newFonts[ key ];
        }
        saveFontManifest( manifest );    
    }
    return manifest;
}
function promptUserForFontPath( font ) {
    var path = CocoaBridge.browseForFile( "Please locate font \"" + font.displayName() + "\"" , [ "otf" , "ttf" ] );
    return path;
}
/* End Font functions */

/* Export functions */
function makeSlice( layer , rect , scaleFactor ) {
    var slice = CocoaBridge.MSSliceMaker.slicesFromExportableLayer( layer , rect ).firstObject();
    slice.page = $doc.currentPage().copyLightweight();
    slice.format = Config.exportImgExt.replace( "." , "" );
    slice.scale = scaleFactor;

    return slice;
}
function exportAsImage( view, filename , scaleFactors ) {
    var slice,
        rect = view.layer.absoluteInfluenceRect(),
        exportFileName,
        exportFileExt = filename.slice( filename.lastIndexOf( "." ) ),
        imageData;

    scaleFactors = scaleFactors || [ Config.exportScaleFactor ];

    scaleFactors.forEach( function( scale ) {
        if( typeof scale !== "number" ) {
            return;
        }
        var scaleStr = ( scale !== 1 ) ? "@" + scale + "x" : "";
        exportFileName = filename.slice( 0 , filename.lastIndexOf( "." ) ) + scaleStr + exportFileExt;
        
        slice = makeSlice( view.layer , rect , scale );

        Util.log("Writing asset " + slice + " to disk: " + exportFileName );
        imageData = CocoaBridge.MSSliceExporter.dataForRequest( slice );
        
        // Convert js string to Obj-C string
        CocoaBridge.writeToFile( imageData , CocoaBridge.stringByAppendingString( exportFileName ) );
    } );
}
function handlerExportForProp( view , bindObj, prop ) {
    var overlay = ( bindObj.overlay && bindObj.overlay.type ) ? bindObj.overlay : contentSpec.create( "image" ),
        layerName = Util.unique( Util.slugify( view.getSanitizedName() ) ),
        filename = Config.targetFolder + "/" + layerName,
        ext = Config.exportImgExt,
        src = filename.replace( Config.targetFolder + "/" , "" ) + ext;

    overlay.setKeyValue( prop , [ src ] );
    bindObj.exportFiles.push( { view: view , target: filename + ext } );
    return overlay;
}
function handlerExport( view , bindObj ) {
    return handlerExportForProp( view , bindObj , "images" );
}
function handlerFontExport( view , bindObj ) {
    var overlay = ( bindObj.overlay && bindObj.overlay.type ) ? bindObj.overlay : contentSpec.create( "text" ),
        nsfont = view.layer.style().textStyle().attributes().NSFont,
        style = overlay.setText();

    bindObj.exportFonts.push( { view: view , fontName: String( nsfont.fontName() ) , font: nsfont , fontStyle: style } );
}
/* End Export functions */

function output( viewData ) {

    var targetFolder = Config.targetFolder,
        json = contentSpec.getJson(),
        exportFiles = [],
        exportFonts = [],
        userFonts = {},
        fontManifest,
        contentSpecStr,
        contentSpecSrc;

    // 1. Create folders
    if( Util.folderExists( Config.targetFolder ) ) {
        Util.removeFolder( Config.targetFolder );
    }

    Util.createFolders( Config.targetFolder , CocoaBridge.Array.arrayWithObjects( targetFolder ) );

    // 2. Compile ContentSpec.json, collect export files
    Util.forEach( viewData , function( data ) {
        // Disable masks for later export
        data.view.disableMask();
        data.view.disableHidden();

        if( data.type === "overlay" ) {
            contentSpec.appendOverlay( data.overlay );
        } else if( data.type === "page" ) {
            contentSpec.appendPage( data.page );
            json.pageSets.pageSet1.pages.push( data.page.getPageId() );
        }

        exportFiles = exportFiles.concat( data.exportFiles );
        exportFonts = exportFonts.concat( data.exportFonts );
    } );

    // 3. Get unique fonts used in project
    exportFonts.forEach( function( font ) {
        if( !userFonts[ font.fontName ] ) {
            userFonts[ font.fontName ] = font.font;
        }
    } );
    fontManifest = checkManifestForFonts( Util.values( userFonts ) );

    exportFonts.forEach( function( fontObj ) {
        var path = fontManifest[ fontObj.fontName ],
            fileName,
            style;
        
        if( !path ) {
            fontObj.fontStyle.setCommonText();
        } else {
            if( CocoaBridge.fileExistsAtPath( path ) ) {
                fileName = path.split( "/" ).slice( -1 )[ 0 ];
                style = fontObj.fontName.split( "-" ).slice( -1 )[ 0 ];
                style = ( fontObj.fontName !== style ) ? style : "Regular";

                contentSpec.addFontMetaData( {
                    fileName: fileName,
                    postScriptName: fontObj.fontName,
                    fullName: String( fontObj.font.displayName() ),
                    familyName: String( fontObj.font.familyName() ),
                    style: style
                } );
                CocoaBridge.copyItemAtPath( path , Config.targetFolder + "/" + fileName );
            }
        }

        fontObj.fontStyle.removeTempValues();
    } );


    // 4. Save ContentSpec.json
    if( json ) {
        contentSpecStr = JSON.stringify( json );
        contentSpecSrc = Config.targetFolder + "/ContentSpec.json";
        Util.saveFileFromString( targetFolder , contentSpecSrc , contentSpecStr );
    }

    // 5. Export images
    if( exportFiles ) {
        Util.forEach( exportFiles , function( fileObj ) {
            exportAsImage( fileObj.view , fileObj.target , [ Config.exportScaleFactor , 2.0 ] );
        } );
    }
    // Re-enable masks
    Util.forEach( viewData , function( data ) {
        data.view.enableMask();
        data.view.enableHidden();
    } );

    // 6. Copy resources
    if( CocoaBridge.fileExistsAtPath( Config.resourcesPath + "/__studio__preferences.json" ) ) {
        CocoaBridge.copyItemAtPath( Config.resourcesPath + "/__studio__preferences.json",
            Config.targetFolder + "/__studio__preferences.json" );
    }
    if( CocoaBridge.fileExistsAtPath( Config.resourcesPath + "/" + contentSpec.getResetCss() ) ) {
        CocoaBridge.copyItemAtPath( Config.resourcesPath + "/" + contentSpec.getResetCss(),
            Config.targetFolder + "/" + contentSpec.getResetCss() );
    }
}
function main( context , viewBinding ) {
    try {
        log("#################################");
        log("### Export ScrollMotion start ###");
        log("#################################");

        var layers = context.document.currentPage().layers(),
            eligibleViews = [],
            processResults;

        // 1. Process Arboards and layers without [ignore] binding
        layers = Util.forEach( layers , function( res ) {
            var view = View.create( res );
            if( view.isArtboard() ) {
                if( !view.shouldBeIgnored() ) {
                    eligibleViews.push( view );
                }
            }
        } );

        // 2. Apply Sketch layer and overlay bindings
        Util.forEach( eligibleViews , function( view ) {
            viewBinding.applyBindings( view );
        } );

        processResults = viewBinding.mapOutput();

        Util.debug.debug( JSON.stringify( processResults ) );

        // 3. Prepare outputs
        output( processResults );

        log("#################################");
        log("#### Export ScrollMotion end ####");
        log("#################################");

    } catch( e ) {
        log( "Uncaught " + e );
    }
}

var onRun = function( context ) {

    initVars( context );
    Config.init( context );

    var viewBinding = new ViewBinding();

    // Register handlers for Sketch data models
    viewBinding.registerObjectGenerator( "default" , function( bindObj ) {
        var view = bindObj.view,
            overlay = handlerExport( view , bindObj );
        overlay.setOverlayId();
        overlay.setKeyValue( "displayName" , view.getSanitizedName() );

        bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
        bindObj.overlay = overlay;
    } );
    viewBinding.registerObjectGenerator( "Artboard" , function( bindObj ) {
        var view = bindObj.view,
            page = contentSpec.create( "page" );
        page.setPageId();
        page.setKeyValue( "displayName" , view.getSanitizedName() );

        bindObj.page = page;
    } );
    viewBinding.registerObjectGenerator( "Bitmap" , function( bindObj ) {
        var view = bindObj.view,
            overlay = handlerExport( view , bindObj );
        overlay.setOverlayId();
        overlay.setKeyValue( "displayName" , view.getSanitizedName() );


        bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
        bindObj.overlay = overlay;

    } );
    viewBinding.registerObjectGenerator( "LayerGroup" , function( bindObj ) {
        var view = bindObj.view,
            overlay = contentSpec.create( "container" ),
            frame = view.getAbsoluteLayout(),
            scrollFrame = view.getInfluenceLayoutSansStyles(),
            scrollHoriz = scrollFrame.width > frame.width,
            scrollVert = scrollFrame.height > frame.height,
            scrollDirection = "none";
        overlay.setOverlayId();
        overlay.setKeyValue( "displayName" , view.getSanitizedName() );

        if( scrollHoriz && scrollVert ) {
            scrollDirection = "both";
        } else if( scrollHoriz ) {
            scrollDirection = "horizontal";
        } else if( scrollVert ) {
            scrollDirection = "vertical";
        }

        overlay.setKeyValue( "userScrolling" , scrollDirection );
        overlay.setKeyValue( "contentHeight" , Util.toPx( scrollFrame.height ) );
        overlay.setKeyValue( "contentWidth" , Util.toPx( scrollFrame.width ) );

        bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
        bindObj.overlay = overlay;
    } );
    viewBinding.registerObjectGenerator( "Text" , {
        object: function( bindObj ) {
            var view = bindObj.view,
                overlay = contentSpec.create( "text" ),
                textAlign = this.alignment( view.layer );
            overlay.setOverlayId();
            overlay.setKeyValue( "displayName" , view.getSanitizedName() );

            // Not officially exposed
            // Util.log( view.layer.style().textStyle().attributes().NSFont.displayName() );
            // Util.log( view.layer.style().textStyle().attributes().NSFont.familyName() );
            // Util.log( String( view.layer.fontPostscriptName() ) );

            var text = overlay.setText( String( view.layer.stringValue() ) );
            text.setTextAlign( textAlign );
            text.setLineHeight( Util.toPx( view.layer.lineSpacing() ) );
            text.setLetterSpacing( Util.toPx( view.layer.characterSpacing() ) );
            text.setColor( Util.toHex( view.layer.textColor() ) );
            text.setFontSize( Util.toPx( view.layer.fontSize() ) );
            text.setCustomFont( String( view.layer.fontPostscriptName() ) , String( view.layer.style().textStyle().attributes().NSFont.familyName() ) );

            bindObj.setupRectforOverlay( overlay , bindObj.view , bindObj.parent.view );
            bindObj.overlay = overlay;

            handlerFontExport( view , bindObj );
        },
        alignment: function( layer ) {
            var alignment = layer.textAlignment();

            if( alignment == 1 ) {
                return "right";
            } else if( alignment == 2 ) {
                return "center";
            } else if( alignment == 3 ) {
                return "justify";
            } else {
                return "left"; // ( 0 )
            }
        }
    } );
    viewBinding.registerObjectGenerator( "Rect" , function( bindObj ) {} );

    // Register handlers for Content Spec data model generation
    viewBinding.registry( "default" , function( bindObj , args ) {
        //we do nothing!
    } );
    viewBinding.registry( "ignore" , {
        stopAutoApplyBindingForChildren: true
    } );
    viewBinding.registry( "flat" , {
        compose: function( bindObj , args ) {
            var overlay = bindObj.overlay;
            overlay.convertToOverlay( "image" , "overlayId" , "layouts" , "displayName" );
            bindObj.overlay = overlay;

            viewBinding.objectGenerators[ "Bitmap" ].object( bindObj );
        },
        stopAutoApplyBindingForChildren: true
    } );
    viewBinding.registry( "btn" , {
        init: function() {
            // This method will only be called when this binding first be used.
        },
        compose: function( bindObj , args ) {
            var view = bindObj.view,
                overlay = bindObj.overlay,
                views,
                needExport,

                // Helpers for overlay properties
                states = [],
                pos,
                textAlign,
                textPos,
                textColor,
                border,
                cornerRadiusFloat,
                fill,
                pressedFill;


            // Exit if view is not a LayerGroup; view will be exported as an image
            if( !view.hasSubviews ) {
                return;
            }

            views = view.subviews();
            needExport = bindObj.requiresExport( view );


            // Doesn't currently support sub layer groups
            function buttonRequiresExport( view ) {
                var textLayers = [],
                    stateLayers = [];

                if( needExport ) { return true; }

                Util.forEach( view.subviews() , function( subview ) {
                    var kind = subview.getLayerKind();
                    if( kind === "LayerGroup" ) {
                        needExport = true;
                    } else if( kind === "Text" ) {
                        textLayers.push( subview );
                    } else {
                        stateLayers.push( subview );
                    }
                } );

                Util.log( "button: " + view.name + ", has ",
                    textLayers.length + " text layers and ",
                    stateLayers.length + " state layers." );

                // Export if more than 1 text element
                if( textLayers.length <= 1 ) {
                    if( textLayers[ 0 ] ) {
                        needExport = bindObj.requiresExport( textLayers[ 0 ] );
                    }
                } else { 
                    Util.log( view.name + " contains too many text layers" );
                    return true;
                }

                // Export if more than 4 states: images, imagesDown, imagesOn, and imagesDownOn
                if( !needExport && stateLayers.length <= 4 ) {
                    Util.forEach( stateLayers , function( view ) {
                        if( bindObj.requiresExport( view ) ) {
                            needExport = true;
                        }
                    } );
                } else {
                    if( !needExport ) {
                        Util.log( needExport , view.name + " contains too many state layers" );    
                    }
                    needExport = true;
                }


                return needExport;
            }

            // Determine if overlay must be exported as images
            needExport = buttonRequiresExport( view );

            // If requires images, flatten button states
            // Else, capture button properties
            if( needExport ) {
                overlay.convertToOverlay( "button" , "layouts" , "displayName" );

                Util.forEach( views , function( subview ) {
                    var bindings = subview.getNameAttributes(),
                        kind = subview.getLayerKind();

                    if( kind === "Text" ) {
                        // Not yet implemented
                    } else if( kind === "Rectangle" || kind === "LayerGroup" ) {
                        if( bindings.state ) {
                            if( bindings.state.indexOf( "down" ) > -1 ) {
                                overlay = handlerExportForProp( subview , bindObj , "imagesDown" );
                                states.push( "down" );
                            } else if( bindings.state.indexOf( "on" ) > -1 ) {
                                overlay = handlerExportForProp( subview , bindObj , "imagesOn" );
                                states.push( "on" );
                            } else if( bindings.state.indexOf( "downOn" ) > -1 ) {
                                overlay = handlerExportForProp( subview , bindObj , "imagesDownOn" );
                                states.push( "downOn" );
                            }
                        } else {
                            // Normal state
                            overlay = handlerExport( subview , bindObj );
                        }
                    }
                } );

                // Enable toggle if conditions exist
                if( view.getNameAttributes().btn.indexOf( "toggle" ) > -1 ||
                    ( states.indexOf( "down" ) > -1 && states.indexOf( "on" ) > -1 && states.indexOf( "downOn" ) > -1 ) ) {
                        overlay.setKeyValue( "toggle" , true );
                }
            } else {
                overlay.convertToOverlay( "cgbutton" , "layouts" , "displayName" );

                Util.forEach( views , function( subview ) {
                    var bindings = subview.getNameAttributes(),
                        kind = subview.getLayerKind();

                    if( kind === "Text" ) {
                        overlay.setKeyValue( "text" , String( subview.layer.stringValue() ) );
                        textPos = subview.getLayoutRelativeTo( view );
                        textAlign = viewBinding.objectGenerators[ "Text" ].alignment( subview.layer );
                        textColor = subview.layer.textColor();

                    } else if( kind === "Rectangle" ) {

                        if( bindings.state ) { 
                            if( bindings.state.indexOf( "down" ) > -1 ) {
                                // Tapped state
                                if( !pressedFill ) { pressedFill = subview.layer.style().fills().array()[ 0 ]; }
                                states.push( "down" );
                            } else if( bindings.state.indexOf( "on" ) > -1 ) {
                                // Toggled state
                                if( !pressedFill ) { pressedFill = subview.layer.style().fills().array()[ 0 ]; }
                                states.push( "on" );
                            } else if( bindings.state.indexOf( "downOn" ) > -1 ) {
                                // Not a valid CG button state; capture anyways
                                states.push( "downOn" );
                            }
                        } else {
                            // Normal state
                            if( !border ) {
                                border = subview.layer.style().borders().array()[ 0 ];

                                // We know there are children layers since the layer kind is "Rectangle"
                                cornerRadiusFloat = subview.layer.children()[0].cornerRadiusFloat();
                            }
                            if( !fill ) { fill = subview.layer.style().fills().array()[ 0 ]; }
                            if( !pos ) {
                                pos = subview.getLayoutRelativeTo( view );
                            }
                        }
                    }
                } );

                if( states.indexOf( "on" ) > -1 ) {
                    overlay.setKeyValue( "toggle" , true );
                }

                overlay.setKeyValue( "textAlign" , textAlign );
                overlay.setKeyValue( "textPadding" , Util.toPx( textPos.x - pos.x ) );
                overlay.setKeyValue( "cgBorderWidth" , Util.toPx( border.thickness() ) );
                overlay.setKeyValue( "cgBorderColor" , Util.toHex( border.color() ) );
                overlay.setKeyValue( "borderAlpha" , Number( Util.toRgba( border.color() ).split( "," ).pop() ) );
                
                overlay.setKeyValue( "cgButtonColor" , Util.toHex( fill.color() ) );
                // overlay.setKeyValue( "cgButtonAlpha" , Number( Util.toRgba( fill.color() ).split( "," ).pop() ) );
                
                if( pressedFill !== undefined ) {
                    overlay.setKeyValue( "cgButtonPressedAlpha" , Number( Util.toRgba( pressedFill.color() ).split( "," ).pop() ) );
                    overlay.setKeyValue( "cgButtonPressedColor" , Util.toHex( pressedFill.color() ) );
                }
                
                overlay.setKeyValue( "fontColor" , Util.toHex( textColor ) );
                overlay.setKeyValue( "fontPressedColor" , Util.toHex( textColor ) );
                
                // Ensure corner radius doesn't exceed half of smallest dimension
                overlay.setKeyValue( "cgCornerRadius" , Util.toPx( 
                    ( cornerRadiusFloat <= Math.min( pos.width , pos.height ) / 2 ) ? 
                        cornerRadiusFloat : Math.min( pos.width , pos.height ) / 2
                ) );
            }

            bindObj.overlay = overlay;
        },
        actions: function( bindObj , args ) {},
        //we will take the children from here
        stopAutoApplyBindingForChildren: true
    } );
    // Binding.registry( "container" , function( layer , args , outputRef ) {
    //     // scroll
    //     // paging
    // } );
    // Binding.registry( "text" , function( layer , args , outputRef ) {} );
    // Binding.registry( "textfield" , function( layer , args , outputRef ) {} );
    // Binding.registry( "proxy" , function( layer , args , outputRef ) {} );

    main( context , viewBinding );
    $doc.showMessage( "Project exported to \"" + Config.targetFolder + "\"" );
};